<!DOCTYPE html>
<html>
<head>
    <title>Emoji Archer</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #menu { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: white; }
        button { padding: 15px 30px; font-size: 20px; background: #4CAF50; border: none; color: white; cursor: pointer; }
        #hud { position: fixed; top: 10px; left: 10px; color: white; font-family: Arial; }
    </style>
</head>
<body>
    <div id="menu">
        <h1>Emoji Archer</h1>
        <button onclick="startGame()">Start Game</button>
        <p>Drag and release to shoot!</p>
    </div>
    <div id="hud">Score: 0 | Level: 1</div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Game state
        let gameState = 'menu';
        let bow = { x: 100, y: canvas.height/2 };
        let arrows = [];
        let targets = [];
        let particles = [];
        let score = 0;
        let level = 1;
        let dragStart = null;

        class Arrow {
            constructor(x, y, dx, dy) {
                this.x = x;
                this.y = y;
                this.dx = dx;
                this.dy = dy;
                this.active = true;
            }

            update() {
                if(!this.active) return;
                
                this.dy += 0.3; // Gravity
                this.x += this.dx;
                this.y += this.dy;

                // Ground collision
                if(this.y > canvas.height - 50) {
                    this.active = false;
                    createImpact(this.x, this.y);
                }
            }

            draw() {
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x - this.dx/2, this.y - this.dy/2);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        class Target {
            constructor() {
                this.x = Math.random() * (canvas.width - 100) + 50;
                this.y = Math.random() * (canvas.height - 150) + 50;
                this.size = 25;
                this.color = `hsl(${Math.random() * 360}, 70%, 50%)`;
                this.dx = (Math.random() - 0.5) * 4;
                this.dy = (Math.random() - 0.5) * 4;
            }

            update() {
                this.x += this.dx;
                this.y += this.dy;
                
                if(this.x < 0 || this.x > canvas.width) this.dx *= -1;
                if(this.y < 0 || this.y > canvas.height - 50) this.dy *= -1;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
        }

        function createImpact(x, y) {
            for(let i = 0; i < 20; i++) {
                particles.push({
                    x, y,
                    dx: (Math.random() - 0.5) * 5,
                    dy: (Math.random() - 2) * 3,
                    size: Math.random() * 4 + 2,
                    alpha: 1
                });
            }
        }

        function startGame() {
            gameState = 'playing';
            document.getElementById('menu').style.display = 'none';
            arrows = [];
            targets = [];
            particles = [];
            score = 0;
            level = 1;
            
            // Initialize targets
            for(let i = 0; i < 5; i++) {
                targets.push(new Target());
            }
        }

        function updateGame() {
            // Update arrows
            arrows.forEach(arrow => arrow.update());
            arrows = arrows.filter(arrow => arrow.active);

            // Update targets
            targets.forEach(target => target.update());

            // Update particles
            particles.forEach(p => {
                p.x += p.dx;
                p.y += p.dy;
                p.alpha -= 0.02;
            });
            particles = particles.filter(p => p.alpha > 0);

            // Collision detection
            arrows.forEach((arrow, aIdx) => {
                targets.forEach((target, tIdx) => {
                    const dx = arrow.x - target.x;
                    const dy = arrow.y - target.y;
                    if(Math.sqrt(dx*dx + dy*dy) < target.size + 10) {
                        score += 100;
                        level = Math.floor(score / 500) + 1;
                        targets.splice(tIdx, 1);
                        arrows.splice(aIdx, 1);
                        targets.push(new Target());
                        createImpact(target.x, target.y);
                    }
                });
            });

            document.getElementById('hud').innerHTML = `Score: ${score} | Level: ${level}`;
        }

        function drawGame() {
            // Clear canvas
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw ground
            ctx.fillStyle = '#1B5E20';
            ctx.fillRect(0, canvas.height - 50, canvas.width, 50);

            // Draw bow
            ctx.beginPath();
            ctx.arc(bow.x, bow.y, 20, 0, Math.PI*2);
            ctx.fillStyle = '#795548';
            ctx.fill();

            // Draw arrows
            arrows.forEach(arrow => arrow.draw());

            // Draw targets
            targets.forEach(target => target.draw());

            // Draw particles
            particles.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                ctx.fillStyle = `rgba(255,255,255,${p.alpha})`;
                ctx.fill();
            });
        }

        // Input handling
        canvas.addEventListener('mousedown', e => {
            dragStart = { x: e.clientX, y: e.clientY };
        });

        canvas.addEventListener('mouseup', e => {
            if(!dragStart || gameState !== 'playing') return;
            
            const dx = (dragStart.x - e.clientX) / 10;
            const dy = (dragStart.y - e.clientY) / 10;
            
            arrows.push(new Arrow(
                bow.x,
                bow.y,
                dx,
                dy
            ));
            
            dragStart = null;
        });

        // Game loop
        function gameLoop() {
            if(gameState === 'playing') {
                updateGame();
                drawGame();
            }
            requestAnimationFrame(gameLoop);
        }

        // Start the game
        gameLoop();
    </script>
</body>
</html>
